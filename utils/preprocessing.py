import torch
import numpy as np
import copy

from general_config import anchor_config


def create_anchors():
    # taken from fastai
    '''
    returns in the following format:
    k = zooms * ratios

    A = (grid_size1 ** 2 * k) + (grid_size2 ** 2 * k) +....+ (grid_sizen ** 2 * k) X 4

    where first k lines for this matrix are anchors centered in the top left corner cell of the first grid
    the next k lines are centered in the cell to the right of that (so they are generated by LINES)
    after the first grid is finished comes the next and so on
    '''
    def create(anc_grids, anc_zooms, anc_ratios):
        anchor_scales = [(anz*i, anz*j) for anz in anc_zooms for (i, j) in anc_ratios]
        anc_offsets = [1/(o*2) for o in anc_grids]
        k = len(anchor_scales)

        anc_x = np.concatenate([np.repeat(np.linspace(ao, 1-ao, ag), ag)
                                for ao, ag in zip(anc_offsets, anc_grids)])
        anc_y = np.concatenate([np.tile(np.linspace(ao, 1-ao, ag), ag)
                                for ao, ag in zip(anc_offsets, anc_grids)])
        anc_ctrs = np.repeat(np.stack([anc_x, anc_y], axis=1), k, axis=0)

        anc_sizes = np.concatenate([np.array([[o/ag, p/ag] for i in range(ag*ag) for o, p in anchor_scales])
                                    for ag in anc_grids])

        grid_sizes = torch.from_numpy(np.concatenate([np.array([1/ag for i in range(ag*ag) for o, p in anchor_scales])
                                                      for ag in anc_grids])).unsqueeze(1)

        anchors = torch.from_numpy(np.concatenate([anc_ctrs, anc_sizes], axis=1)).float()

        return anchors, grid_sizes

    anchors, grid_sizes = [], []
    for (k_zoom, v_zoom), (k_ratio, v_ratio) in zip(anchor_config.zoom.items(), anchor_config.ratio.items()):
        if v_zoom != []:
            cur_anchors, cur_grid_sizes = create([k_zoom], v_zoom, v_ratio)
            anchors.append(cur_anchors)
            grid_sizes.append(cur_grid_sizes)

    anchors = torch.cat(anchors)
    grid_sizes = torch.cat(grid_sizes)

    # are currently (y,x,h,w), want (x,y,w,h)
    temp = copy.deepcopy(anchors[:, 0])
    anchors[:, 0] = anchors[:, 1]
    anchors[:, 1] = temp

    temp = copy.deepcopy(anchors[:, 2])
    anchors[:, 2] = anchors[:, 3]
    anchors[:, 3] = temp

    return anchors, grid_sizes


def prepare_gt(input_img, gt_target):
    '''
    args:
    - input_img: PIL image HxW
    - gt_target: list of gt bbox coords: (x,y,w,h)

    return:
    gt[0] = tensor of bboxes of objects in image scaled [0,1], in (CENTER, w, h) format
    gt[1] = tensor of class ids in image
    '''
    gt_bboxes, gt_classes = [], []
    for obj in gt_target:
        gt_bboxes.append(obj['bbox'])
        gt_classes.append(obj['category_id'])

    gt = [torch.FloatTensor(gt_bboxes), torch.IntTensor(gt_classes)]

    width, height = input_img.size

    for idx, bbox in enumerate(gt[0]):
        new_bbox = [0] * 4
        new_bbox[0] = (bbox[0] + (bbox[2] / 2)) / width
        new_bbox[1] = (bbox[1] + (bbox[3] / 2)) / height
        new_bbox[2] = bbox[2] / width
        new_bbox[3] = bbox[3] / height
        gt[0][idx] = torch.FloatTensor(new_bbox)

    return gt
